<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初心不变</title>
  
  <subtitle>积跬步,行至天涯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://myLiJuXin.com/"/>
  <updated>2018-08-21T12:57:40.000Z</updated>
  <id>http://myLiJuXin.com/</id>
  
  <author>
    <name>LJX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DJANGO框架如何实现用户多认证方式登录与第三方授权登录</title>
    <link href="http://myLiJuXin.com/2018/08/21/DJANGO%E6%A1%86%E6%9E%B6%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%B4%A6%E5%8F%B7%E7%99%BB%E5%BD%95%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95/"/>
    <id>http://myLiJuXin.com/2018/08/21/DJANGO框架如何实现多账号登录与第三方登录/</id>
    <published>2018-08-21T11:38:20.000Z</published>
    <updated>2018-08-21T12:57:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多种认证方式登录"><a href="#多种认证方式登录" class="headerlink" title="多种认证方式登录"></a>多种认证方式登录</h2><p>Django框架提供了认证系统，详情看文档<a href="https://yiyibooks.cn/xx/Django_1.11.6/topics/auth/index.html" target="_blank" rel="noopener">Django认证系统官方文档</a></p><p>在这个认证系统中，有一个用户认证的方法authenticate（）来验证一组凭据，默认的是username和password，官方调用源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from django.contrib.auth import authenticate</span><br><span class="line">user = authenticate(username=&apos;john&apos;, password=&apos;secret&apos;)</span><br><span class="line">if user is not None:</span><br><span class="line">    # A backend authenticated the credentials</span><br><span class="line">else:</span><br><span class="line">    # No backend authenticated the credentials</span><br></pre></td></tr></table></figure><p>所以只需要重写这个方法，就可以实现多凭证登录。<br>方法如下：<br>1.在user应用下新建utils.py文件<br>2.定义类继承Modelbackend，重写authenticate方法<br>3.重写规则，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 重写authenticate方法，继承ModelBackend这个类来重写方法</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.backends <span class="keyword">import</span> ModelBackend</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> User</span><br><span class="line">class UserModelBackend(ModelBackend):</span><br><span class="line">    def authenticate(self, request, username=None, password=None, **kwargs):</span><br><span class="line">        # 判断用户输入的是手机号还是用户名</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            # 查询对象，如果能查到对象则得到返回的对象</span><br><span class="line">            user = User.objects.filter(mobile=username)</span><br><span class="line">            # 如果不是手机用户，则执行except</span><br><span class="line">        except:</span><br><span class="line">            # 判断是否用户名，与用户名对比</span><br><span class="line">            <span class="keyword">try</span>: </span><br><span class="line">                user = User.objects.filter(username=username)</span><br><span class="line">            except:</span><br><span class="line">                # 都不是返回空</span><br><span class="line">                <span class="keyword">return</span> None</span><br><span class="line">        # 如果查询到用户对象，则检查密码</span><br><span class="line">        <span class="keyword">if</span> user.check_password(password):</span><br><span class="line">            <span class="keyword">return</span> user</span><br><span class="line">        <span class="keyword">return</span> None</span><br></pre></td></tr></table></figure><p>4.配置中设置，settings中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AUTHENTICATION_BACKENDS=[</span><br><span class="line"><span class="string">'users.utils.UsernameMobileModelBackend'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>即可实现使用用户手机号登录。</p><h2 id="授权第三方登录（QQ为例）"><a href="#授权第三方登录（QQ为例）" class="headerlink" title="授权第三方登录（QQ为例）"></a>授权第三方登录（QQ为例）</h2>]]></content>
    
    <summary type="html">
    
      登录时单用户支持多种方式登录，添加第三方授权登录，腾讯qq为例
    
    </summary>
    
      <category term="web开发" scheme="http://myLiJuXin.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,登录" scheme="http://myLiJuXin.com/tags/web-%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于session与JWT的认证机制</title>
    <link href="http://myLiJuXin.com/2018/08/21/%E5%85%B3%E4%BA%8Esession%E4%B8%8EJWT%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/"/>
    <id>http://myLiJuXin.com/2018/08/21/关于session与JWT的认证机制/</id>
    <published>2018-08-21T06:45:42.000Z</published>
    <updated>2018-08-21T13:09:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是状态保持"><a href="#什么是状态保持" class="headerlink" title="什么是状态保持"></a>什么是状态保持</h2><p>说到状态保持，首先要讲一下什么是无状态，http 就是一种无状态协议，浏览器请求服务器是无状态的。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>指用户请求过一次后，浏览器与服务器无法知道这个用户做过什么，下一次请求还是新的请求。<br><br><br>发生无状态的原因：浏览器与服务器之间是使用socket套接字通讯的，在一次访问结束后，服务器将访问结果返回给浏览器之后，会关闭当前的socket连接，浏览器在关闭后，服务器也会销毁当前的页面对象。</p><h3 id="无状态协议"><a href="#无状态协议" class="headerlink" title="无状态协议"></a>无状态协议</h3><p>1.协议对于事务处理没有记忆能力。<br>2.对同一个 url 请求没有上下文关系。<br>3.每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的4请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况。<br>4.服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器。</p><h3 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h3><p>与无状态相反，相当于有记忆能力，可以记录之前用户的操作，即状态保持，那怎么实现状态保持呢？</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="Cookie的定义"><a href="#Cookie的定义" class="headerlink" title="Cookie的定义"></a>Cookie的定义</h3><p>指某些网站为了辨别用户身份、进行会话跟踪而储存在用户本地的数据。（通常经过加密）<br><br><br>cookie由服务器端生成，发送给客户端浏览器，浏览器可以将cookie的key/value进行保存，下次请求同一网站时就会将cookie同请求信息发送给服务器。<br><br><br>通过cookie就实现了状态保持，即用户登陆过的信息，访问过的页面数据，都会被放在cookie里进行记录，保存在浏览器，下次请求这个网站时会发送给服务器，服务器就能从cookie中快速获取信息，即知道了用户已经登陆过，访问了哪些数据，保持了用户的登录状态，将相关数据快速呈现。</p><h3 id="使用cookie的注意事项"><a href="#使用cookie的注意事项" class="headerlink" title="使用cookie的注意事项"></a>使用cookie的注意事项</h3><ol><li>cookie是基于域名安全的，不同域名的cookie是不能互相访问的，即同源策略。（在这个页面里可以嵌入窗口iframe，来访问其他域名的cookie）</li><li>Cookie是存储在浏览器中的一段纯文本信息，建议不要存储敏感信息如密码，因为电脑上的浏览器可能被其它人使用。</li><li>因为cookie被放在请求报文里发送给服务器，所以服务器端可以通过request对象来获取cookie信息，进行操作。</li></ol><h3 id="设置cookie与获取cookie"><a href="#设置cookie与获取cookie" class="headerlink" title="设置cookie与获取cookie"></a>设置cookie与获取cookie</h3><h4 id="设置cookie"><a href="#设置cookie" class="headerlink" title="设置cookie"></a>设置cookie</h4><p>获取response对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.set_cookie(‘键’，‘值’，max_age=<span class="number">3600</span>）</span><br></pre></td></tr></table></figure><p>max_age为过期时间，即第一次访问产生cookie之后，3600秒会自动删除。</p><h4 id="获取cookie"><a href="#获取cookie" class="headerlink" title="获取cookie"></a>获取cookie</h4><p>请求对象request</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.cookies.get(<span class="string">'键'</span>)</span><br></pre></td></tr></table></figure><p>根据之前设置的键就能获取到cookie的值。</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>cookie说到建议不要保存用户的敏感信息，很容易会被破解，那么这些敏感信息怎么解决，比如用户登录的用户名，密码，这就要用到session来认证用户。</p><h3 id="理解session的机制"><a href="#理解session的机制" class="headerlink" title="理解session的机制"></a>理解session的机制</h3><p>对于敏感的信息，要保存在服务器中，不能存储在浏览器中，而服务器采用的状态保持的方案就是session认证。<br><br>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。</p><h3 id="session依赖于cookie"><a href="#session依赖于cookie" class="headerlink" title="session依赖于cookie"></a>session依赖于cookie</h3><p>客户端在访问后，由服务端生成session，根据每一个session都会生成它的唯一标识（uuid），然后以session为键，这个唯一标识为值，存放在cookie里。同时服务端本地也会存session（非关系型数据库存储，如redis），以uuid为键，session的键值对为值，存进服务端本地，访问时，根据这个唯一标识在本地进行读取操作。</p><h4 id="url重写技术"><a href="#url重写技术" class="headerlink" title="url重写技术"></a>url重写技术</h4><p>由于cookie可以被人为的禁止，必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面，附加方式也有两种，一种是作为URL路径的附加信息，表现形式为<code>http://...../xxx;jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code><br>另一种是作为查询字符串附加在URL后面，表现形式为<code>http://...../xxx?jsessionid=ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764</code><br>这两种方式对于用户来说是没有区别的，只是服务器在解析的时候处理的方式不同，采用第一种方式也有利于把session id的信息和正常程序参数区分开来。<br>为了在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。</p><h4 id="表单隐藏字段技术"><a href="#表单隐藏字段技术" class="headerlink" title="表单隐藏字段技术"></a>表单隐藏字段技术</h4><p>另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如下面的表单： </p><pre><code>&lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; 在被传递给客户端之前将被改写成： &lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&gt; &lt;input type=&quot;text&quot;&gt; &lt;/form&gt; </code></pre><p>这种技术使用相对较少了。</p><h3 id="session数据的读写"><a href="#session数据的读写" class="headerlink" title="session数据的读写"></a>session数据的读写</h3><h4 id="读取session数据"><a href="#读取session数据" class="headerlink" title="读取session数据"></a>读取session数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.get(<span class="string">'键'</span>)</span><br></pre></td></tr></table></figure><h4 id="写入session数据"><a href="#写入session数据" class="headerlink" title="写入session数据"></a>写入session数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session[<span class="string">'键'</span>] = <span class="string">'值'</span></span><br></pre></td></tr></table></figure><h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><h3 id="session认证所显露的问题"><a href="#session认证所显露的问题" class="headerlink" title="session认证所显露的问题"></a>session认证所显露的问题</h3><p>1.用户通过session认证，都要在服务器端做一次记录，而session是保存在服务器端的内存中，随着用户的增多，服务器端的开销会明显增大。<br>2.而且用户下次请求还必须要请求在这台服务器上,这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。<br>3.session是依赖于cookie，如果cookie被截获，很容易受到跨站请求伪造的攻击（csrf），安全性不足。<br><br><br>这就引入了jwt认证机制</p><h3 id="什么是JWT"><a href="#什么是JWT" class="headerlink" title="什么是JWT"></a>什么是JWT</h3><p>JWT，全名Json Web Token，是一种基于token的认证机制，类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。<br><br>流程上是这样的：</p><ul><li>用户使用用户名密码来请求服务器 </li><li>服务器进行验证用户的信息 </li><li>服务器通过验证发送给用户一个token</li><li>客户端存储token，并在每次请求时附送上这个token值 </li><li>服务端验证token值，并返回数据</li></ul><h3 id="JWT的构成"><a href="#JWT的构成" class="headerlink" title="JWT的构成"></a>JWT的构成</h3><p>例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span><br></pre></td></tr></table></figure></p><p>如上所示，是一个JWT的token，分为三个部分</p><h4 id="header头部"><a href="#header头部" class="headerlink" title="header头部"></a>header头部</h4><p>第一部分header存两部分信息<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  'typ': 'JWT',  # 声明类型为jwt</span><br><span class="line">  'alg': 'HS256' # 加密算法 HMAC SHA256</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过base64算法加密构成第一部分，<code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></p><h4 id="payload载荷"><a href="#payload载荷" class="headerlink" title="payload载荷"></a>payload载荷</h4><p>载荷是存放有效信息的地方，有效信息分为三部分：</p><ol><li>标准中注册的声明：<br>iss: jwt签发者<br>sub: jwt所面向的用户<br>aud: 接收jwt的一方<br>exp: jwt的过期时间，这个过期时间必须要大于签发时间<br>nbf: 定义在什么时间之前，该jwt都是不可用的.<br>iat: jwt的签发时间<br>jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。</li><li>公共的声明：<br>添加用户信息，不建议添加敏感信息，因为base64算法是对称算法，可解密</li><li>私有的声明：<br>私有声明是提供者和消费者所共同定义的声明。<br>定义一个payload</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="string">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>base64算法加密后就是第二段<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p><h4 id="signature"><a href="#signature" class="headerlink" title="signature"></a>signature</h4><p>jwt的第三部分是一个签证信息，签证信息由三部分组成：<br>header<br>payload<br>secret<br>这部分信息将header、payload中的base64加密后的信息连接成字符串，然后通过header里声明的HS256算法加上secret进行加密，就构成了jwt的第三部分。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">'.'</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">'secret'</span>);</span><br></pre></td></tr></table></figure><p>构成第三部分<code>TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code><br>三部分构成完整的JWT的token</p><p>PS：secret是保存在服务端的，jwt签发也是在服务端，所以secret是服务端的私钥，不能泄露出去。虽然header和payload可以通过base64解密，但是没有secret是无法进行认证的，这就保证了安全性。</p><h3 id="JWT的应用"><a href="#JWT的应用" class="headerlink" title="JWT的应用"></a>JWT的应用</h3><p>Django rest framework中应用jwt<br>详情可参考文档网站：<a href="http://getblimp.github.io/django-rest-framework-jwt/" target="_blank" rel="noopener">JWT官方文档</a></p><h4 id="安装jwt应用"><a href="#安装jwt应用" class="headerlink" title="安装jwt应用"></a>安装jwt应用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install djangorestframework-jwt</span><br></pre></td></tr></table></figure><h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework_jwt.authentication.JSONWebTokenAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">    ),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta(days=<span class="number">1</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JWT_EXPIRATION_DELTA指明jwt的有效期</p><h4 id="使用jwt返回token"><a href="#使用jwt返回token" class="headerlink" title="使用jwt返回token"></a>使用jwt返回token</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"></span><br><span class="line">jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"></span><br><span class="line">payload = jwt_payload_handler(user)</span><br><span class="line">token = jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure><p>比如注册中使用token，因为token要返回输出，所以在定义序列化器时要添加token字段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">token = serializers.CharField(label='登录状态token', read_only=True)  # 增加token字段</span><br></pre></td></tr></table></figure><h4 id="登录功能中使用JWT返回指定字段"><a href="#登录功能中使用JWT返回指定字段" class="headerlink" title="登录功能中使用JWT返回指定字段"></a>登录功能中使用JWT返回指定字段</h4><p>将上面的jwt应用于登录认证时，登录成功后，发现api接口只返回了jwt的token，如图所示</p><img src="/2018/08/21/关于session与JWT的认证机制/1.jpg"><p>如果想将用户的其他字段比如用户名，怎么返回呢<br>jwt配合django的内部框架提供了登录验证功能，在Django框架中直接使用jwt的登录验证视图函数obtain_jwt_token</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from rest_framework_jwt.views import obtain_jwt_token # 导入包</span><br><span class="line">url(r'^路由规则$', obtain_jwt_token), # url中配置地址</span><br></pre></td></tr></table></figure><p>定义以上路由地址即可，jwt自带的登录验证便可应用<br>jwt提供的视图obtain_jwt_token内部逻辑：<br>    1.定义视图类，继承自APIView<br>    2.定义序列化器，继承自Serializer，然后调用django内部贡献的authenticate()方法<br>    3.接收用户名、密码<br>    4.查询数据库，进行密码对比<br>    5.如果成功，则生成口令并返回<br>这是查看obtain_jwt_token的源码，和jwt的官方文档，就可以理解这个视图的工作原理。</p><p>然后自定义接口响应值：<br>1.在users应用下新建utils.py。<br>2.创建函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def jwt_response_payload_handler(token, user=None, request=None):</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="string">'token'</span>: token,</span><br><span class="line"><span class="string">'username'</span>:user.username</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.在settings.py中配置添加<br>    ‘JWT_RESPONSE_PAYLOAD_HANDLER’:’users.utils.jwt_response_payload_handler’,</p><p>然后重新运行即可，效果如下</p><img src="/2018/08/21/关于session与JWT的认证机制/2.jpg"><h3 id="jwt的优点"><a href="#jwt的优点" class="headerlink" title="jwt的优点"></a>jwt的优点</h3><p>1.因为json的通用性，所以JWT是可以进行跨语言支持的，像JAVA,JavaScript,NodeJS,PHP等很多语言都可以使用。<br>2.因为有了payload部分，所以JWT可以在自身存储一些其他业务逻辑所必要的非敏感信息。<br>3.便于传输，jwt的构成非常简单，字节占用很小，所以它是非常便于传输的。<br>4.它不需要在服务端保存会话信息, 所以它易于应用的扩展</p>]]></content>
    
    <summary type="html">
    
      http状态保持，cookies的作用，session与jwt的认证机制
    
    </summary>
    
      <category term="web开发" scheme="http://myLiJuXin.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,状态保持" scheme="http://myLiJuXin.com/tags/web-%E7%8A%B6%E6%80%81%E4%BF%9D%E6%8C%81/"/>
    
  </entry>
  
  <entry>
    <title>关于Celery的异步服务使用</title>
    <link href="http://myLiJuXin.com/2018/08/20/%E5%85%B3%E4%BA%8ECelery%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%8D%E5%8A%A1%E4%BD%BF%E7%94%A8/"/>
    <id>http://myLiJuXin.com/2018/08/20/关于Celery的异步服务使用/</id>
    <published>2018-08-20T01:49:10.000Z</published>
    <updated>2018-08-20T14:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Celery？"><a href="#什么是Celery？" class="headerlink" title="什么是Celery？"></a>什么是Celery？</h3><p>Celery是一个专注于实时处理和任务调度的分布式任务队列。所谓任务就是消息，消息中的有效载荷中包含要执行任务需要的全部数据。</p><h3 id="为什么使用Celery"><a href="#为什么使用Celery" class="headerlink" title="为什么使用Celery"></a>为什么使用Celery</h3><p>在开发应用中，我们难免会遇到耗时操作，或者需要添加一些定时任务，而服务器本身的框架对于多进程、线程等已经写好，这些附加工作就会被耗时处理，而使用Celery则可以很好的处理这些任务，相当于开了一个额外的进程来处理这些耗时任务，增强了执行效率。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li>Web应用。当用户触发的一个操作需要较长时间才能执行完成时，可以把它作为任务交给Celery去异步执行，执行完再返回给用户。这段时间用户不需要等待，提高了用户体验与程序执行效率。</li></ol><ol start="2"><li>定时任务。生产环境经常会跑一些定时任务。假如你有上千台的服务器、上千种任务，定时任务的管理很困难，Celery可以帮助我们快速在不同的机器设定不同种任务。</li></ol><ol start="3"><li>同步完成的附加工作都可以异步完成。比如发送短信/邮件、推送消息、清理/设置缓存等。</li></ol><h3 id="Celery架构"><a href="#Celery架构" class="headerlink" title="Celery架构"></a>Celery架构</h3><img src="/2018/08/20/关于Celery的异步服务使用/1.jpg"><p>Celery Beat：任务调度器，Beat进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。<br>Result Backend：任务处理完后保存状态信息和结果，以供查询。Celery默认已支持Redis、RabbitMQ、MongoDB、Django ORM、SQLAlchemy等方式，当然Redis应该是最佳选择。</p><h3 id="例：对于django框架web开发中发送短信功能使用Celery优化"><a href="#例：对于django框架web开发中发送短信功能使用Celery优化" class="headerlink" title="例：对于django框架web开发中发送短信功能使用Celery优化"></a>例：对于django框架web开发中发送短信功能使用Celery优化</h3><h4 id="为什么要进行优化"><a href="#为什么要进行优化" class="headerlink" title="为什么要进行优化"></a>为什么要进行优化</h4><p>因为发送短信是一个等待操作，用户那边也会设置一个60秒等待操作，为了提高用户体验，增强效率，采用Celery进行优化，设置异步任务，处理短信发送功能。</p><p>1.在mamange.py同目录下，新建工具包celery_tasks<br>2.创建config.py<br>    设置代理人，指定队列，这里连接redis第14个数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broker_url=<span class="string">'redis://‘设置的ip地址’/14'</span></span><br></pre></td></tr></table></figure><p>3.创建main.py，创建Celery的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> . import config</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">#设置django的配置</span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"项目的settings"</span>)</span><br><span class="line"># 创建对象</span><br><span class="line">app = Celery(<span class="string">'任意字符串'</span>)</span><br><span class="line"></span><br><span class="line"># 加载配置</span><br><span class="line">app.config_from_object(config)</span><br><span class="line"></span><br><span class="line"># 初始化任务</span><br><span class="line"># 在指定的包中找tasks.py文件，在这个文件中找@app.task的函数</span><br><span class="line">app.autodiscover_tasks([</span><br><span class="line">    <span class="string">'celery_tasks.sms'</span>,</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>4.新建sms工具包，在包中新建tasks.py文件，定义发送短信的函任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.ytx_sdk.sendSMS <span class="keyword">import</span> CCP</span><br><span class="line"><span class="keyword">from</span> celery_tasks.main <span class="keyword">import</span> app</span><br><span class="line"># 发送短信任务</span><br><span class="line">@app.task(name=<span class="string">'sms_send'</span>)</span><br><span class="line">def sms_send(mobile, sms_code, expires, template_id):</span><br><span class="line">    CCP.sendTemplateSMS(mobile, sms_code, expires, template_id)</span><br></pre></td></tr></table></figure><p>5.启动celery的工人<br>    celery -A celery_tasks.main worker -l info</p><p>6.调用：sms_send.delay(参数)</p>]]></content>
    
    <summary type="html">
    
      在web开发中使用Celery异步服务优化需要等待时长的耗时任务
    
    </summary>
    
      <category term="web开发" scheme="http://myLiJuXin.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,Celery" scheme="http://myLiJuXin.com/tags/web-Celery/"/>
    
  </entry>
  
  <entry>
    <title>关于数据库redis与Mysql的区别以及在web开发中的配合使用</title>
    <link href="http://myLiJuXin.com/2018/08/18/%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8/"/>
    <id>http://myLiJuXin.com/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/</id>
    <published>2018-08-18T13:51:28.000Z</published>
    <updated>2018-08-20T15:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="传统型关系数据库Mysql的瓶颈"><a href="#传统型关系数据库Mysql的瓶颈" class="headerlink" title="传统型关系数据库Mysql的瓶颈"></a>传统型关系数据库Mysql的瓶颈</h3><p>在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。<br><br>关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。</p><h3 id="Nosql与redis"><a href="#Nosql与redis" class="headerlink" title="Nosql与redis"></a>Nosql与redis</h3><p>NoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。</p><h4 id="Nosql的优势"><a href="#Nosql的优势" class="headerlink" title="Nosql的优势"></a>Nosql的优势</h4><p>易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。<br>大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单<br>灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦<br>高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。</p><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><p>Redis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。<br>redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便<br>Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本<br>MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。</p><h3 id="利用redis做mysql的缓存"><a href="#利用redis做mysql的缓存" class="headerlink" title="利用redis做mysql的缓存"></a>利用redis做mysql的缓存</h3><p>前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><img src="/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/1.jpg"><p>页面缓存经常用在CMS(content manage system)内存管理系统里面。<br>数据缓存经常会用在页面的具体数据里面。</p><h4 id="Redis缓存原理"><a href="#Redis缓存原理" class="headerlink" title="Redis缓存原理"></a>Redis缓存原理</h4><p>采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。</p><img src="/2018/08/18/关于数据库redis与Mysql的区别以及在web开发中的配合使用/2.jpg"><p>对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。</p><p>Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。<br>Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。</p><p>用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。</p><table><thead><tr><th>redis中的hash</th><th>python中的字典</th></tr></thead><tbody><tr><td><font color="#000000">key</font></td><td><font color="#000000">对象</font></td></tr><tr><td><font color="#000000">field</font></td><td><font color="#000000">key</font></td></tr><tr><td><font color="#000000">value</font></td><td><font color="#000000">value</font></td></tr></tbody></table><p>即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。</p>]]></content>
    
    <summary type="html">
    
      redis与mysql的优缺点分析，以及在web中的配合使用
    
    </summary>
    
      <category term="数据库" scheme="http://myLiJuXin.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库,redis,mysql" scheme="http://myLiJuXin.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-redis-mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于web开发用户注册功能的图形验证码与短信验证码</title>
    <link href="http://myLiJuXin.com/2018/08/18/%E5%85%B3%E4%BA%8Eweb%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%BD%A2%E9%AA%8C%E8%AF%81%E7%A0%81%E4%B8%8E%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81%E5%8A%9F%E8%83%BD/"/>
    <id>http://myLiJuXin.com/2018/08/18/关于web开发实现图形验证码与短信验证码功能/</id>
    <published>2018-08-18T12:30:58.000Z</published>
    <updated>2018-08-20T02:29:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Flask框架"><a href="#Flask框架" class="headerlink" title="Flask框架"></a>Flask框架</h2><div>前后端不分离</div><h3 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h3><h4 id="Captcha"><a href="#Captcha" class="headerlink" title="Captcha"></a>Captcha</h4><div>1.基于captcha实现图片验证码，什么是captcha？<br><br>Captcha是一个第三方工具，提供生成验证码图片通用解决办法，提供了非常灵活的生成验证码图片的框架，可以自由的组合生成图片过程中的各种元素，例如，字体、颜色、背景、扭曲样式等，不仅提供了丰富的变形资源，即使不能满足需求的情况下，也可以实现固有的接口，创造出自己的字体变形的方式，所以该框架应该可以满足生成验证图片的大部分需求。<br><br><br>#### Flask框架中使用captcha完成图片验证码功能<br><br><br>将chptcha的第三方包放在utils文件夹中，utils是基于python创建一个flask工程后一个专门存放第三方工具包的文件夹。然后在功能视图模块中</div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils.captcha.captcha <span class="keyword">import</span> captcha</span><br></pre></td></tr></table></figure><p>视图函数中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># @user_blueprint是flask框架中，经过创建蓝图，蓝图注册的路由，后面是路由地址</span><br><span class="line">@user_blueprint.route(<span class="string">'/image_code'</span>)</span><br><span class="line">def image_code():</span><br><span class="line">    # 调用第三方的工具，生成图形验证码数据</span><br><span class="line">    name, text, image = captcha.generate_captcha()</span><br><span class="line">    # 保存text值，存放于session中，用于后续的对比验证</span><br><span class="line">    session[<span class="string">'image_code'</span>] = text</span><br><span class="line"> </span><br><span class="line">    # 创建响应对象，响应体为图片数据</span><br><span class="line">    response = make_response(image)</span><br><span class="line">    # 注意：这里一定要设置响应数据的类型为图片，不然会在网页上无法显示，生成乱码数据</span><br><span class="line">    response.content_type = <span class="string">'image/png'</span></span><br><span class="line">    # 返回到响应体</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>在首页的页面中index.html中，添加如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"/user/image_code?1"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"get_pic_code"</span> onclick=<span class="string">"generateImageCode()"</span>&gt;</span><br></pre></td></tr></table></figure><p>显示图片，设置css样式，并绑定点击事件，生成图片验证码<br>然后在main.js（主页js里）添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateImageCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.get_pic_code'</span>).attr(<span class="string">'src'</span>, $(<span class="string">'.get_pic_code'</span>).attr(<span class="string">'src'</span>) + <span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点击事件，点击即修改他的src属性，重新生成图片验证码，即可实现<br>$(‘.get_pic_code’)是类选择器，attr获取其src属性进行修改</p><h3 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h3><h4 id="容联云通讯"><a href="#容联云通讯" class="headerlink" title="容联云通讯"></a>容联云通讯</h4><p>容联云通讯为第三方服务，云通讯平台将传统电信网络通讯能力、基于IP的通讯能力，通过开放API的方式提供给开发者与合作伙伴，让开发者们在应用程序中集成网络电话和电话会议功能变得简单。<br><br>可提供语音、IVR、短信、IM、视频等web开发接口，这里使用短信功能，详情可查看官方开发文档<a href="http://doc.yuntongxun.com/space/5a5098313b8496dd00dcdd7f" target="_blank" rel="noopener">点这里</a><br>查看基于python的短信发送接口。</p><h4 id="实现短信验证码发送功能"><a href="#实现短信验证码发送功能" class="headerlink" title="实现短信验证码发送功能"></a>实现短信验证码发送功能</h4><p>将云通讯第三方工具包放入utils文件夹中，云通讯文档使用说明：<br>1.接口声明文件：SDK \CCPRestSDK.py</p><p>2.接口函数定义：def sendTemplateSMS(self, to,datas,tempId) </p><p>3.参数说明：</p><p>to: 短信接收手机号码集合,用英文逗号分开,如 ‘13810001000,13810011001’,最多一次发送200个。</p><p>datas：内容数据，需定义成数组方式，如模板中有两个参数，定义方式为array[‘Marry’,’Alon’]。 </p><p>templateId: 模板Id,如使用测试模板，模板id为”1”，如使用自己创建的模板，则使用自己创建的短信模板id即可。<br>4.接口调用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">编码说明：coding=utf<span class="number">-8</span>或gbk</span><br><span class="line"> <span class="keyword">from</span> CCPRestSDK <span class="keyword">import</span> REST</span><br><span class="line"> <span class="keyword">import</span> ConfigParser</span><br><span class="line"> </span><br><span class="line"> accountSid= <span class="string">'您的主账号'</span>; </span><br><span class="line"> #说明：主账号，登陆云通讯网站后，可在控制台首页中看到开发者主账号ACCOUNT SID。</span><br><span class="line"> </span><br><span class="line"> accountToken= <span class="string">'您的主账号Token'</span>; </span><br><span class="line"> #说明：主账号Token，登陆云通讯网站后，可在控制台首页中看到开发者主账号AUTH TOKEN。</span><br><span class="line"> </span><br><span class="line"> appId=<span class="string">'您的应用ID'</span>; </span><br><span class="line"> #请使用管理控制台中已创建应用的APPID。</span><br><span class="line"> </span><br><span class="line"> serverIP=<span class="string">'app.cloopen.com'</span>;</span><br><span class="line"> #说明：请求地址，生产环境配置成app.cloopen.com。</span><br><span class="line"> </span><br><span class="line"> serverPort=<span class="string">'8883'</span>; </span><br><span class="line"> #说明：请求端口 ，生产环境为8883.</span><br><span class="line"> </span><br><span class="line"> softVersion='2013-12-26'; #说明：REST API版本号保持不变。 </span><br><span class="line"> </span><br><span class="line"> def sendTemplateSMS(to,datas,tempId): </span><br><span class="line">    #初始化REST SDK</span><br><span class="line">    rest = REST(serverIP,serverPort,softVersion) </span><br><span class="line">    rest.setAccount(accountSid,accountToken) </span><br><span class="line">    rest.setAppId(appId)</span><br><span class="line"> </span><br><span class="line">    result = rest.sendTemplateSMS(to,datas,tempId) </span><br><span class="line">    <span class="keyword">for</span> k,v <span class="keyword">in</span> result.iteritems():</span><br><span class="line">        <span class="keyword">if</span> k==<span class="string">'templateSMS'</span> : </span><br><span class="line">                <span class="keyword">for</span> k,s <span class="keyword">in</span> v.iteritems():</span><br><span class="line">                    print <span class="string">'%s:%s'</span> % (k, s) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            print <span class="string">'%s:%s'</span> % (k, v)</span><br></pre></td></tr></table></figure><p>在视图函数中定义如下视图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 蓝图注册</span><br><span class="line">@user_blueprint.route(<span class="string">'/sms_code'</span>)</span><br><span class="line">def sms_code():</span><br><span class="line">    # 接收:手机号，图形验证码，从请求报文中接收</span><br><span class="line">    mobile = request.args.get(<span class="string">'mobile'</span>)</span><br><span class="line">    imagecode = request.args.get(<span class="string">'imagecode'</span>)</span><br><span class="line"></span><br><span class="line">    # 验证</span><br><span class="line">    # 1.值必填  空在python中为False</span><br><span class="line">    # 如果都不为空</span><br><span class="line">    <span class="keyword">if</span> not all([mobile, imagecode]):</span><br><span class="line">        # 返回json数据格式，由前端代码进一步处理</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 2.检验图形验证码一致，之前图形验证码已经存在session中</span><br><span class="line">    imagecode_session = session.get(<span class="string">'image_code'</span>)</span><br><span class="line">    <span class="keyword">if</span> not imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">4</span>)</span><br><span class="line">    # 删除session中的数据，强制图形验证码过期，防止客户端不停尝试</span><br><span class="line">    del session[<span class="string">'image_code'</span>]</span><br><span class="line"># 验证码不对的情况</span><br><span class="line">    <span class="keyword">if</span> imagecode != imagecode_session:</span><br><span class="line">        <span class="keyword">return</span> jsonify(result=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    # 处理</span><br><span class="line">    # 1.通过random随机数生成随机的验证码</span><br><span class="line">    smscode = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">    # 2.保存验证码，用于后续验证，存到session中</span><br><span class="line">    session[<span class="string">'sms_code'</span>] = smscode</span><br><span class="line">    # 3.发送短信，云通讯工具包中封装好的函数功能</span><br><span class="line">    ytx_send.sendTemplateSMS(mobile, [smscode, <span class="string">'10'</span>], <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    # 响应</span><br><span class="line">    <span class="keyword">return</span> jsonify(result=<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>在mian.JS中修改如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送短信验证码的点击事件，页面css已经由前端绑定好</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendSMSCode</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验参数，保证输入框有数据填写</span></span><br><span class="line"><span class="comment">// 先移除绑定事件，防止用户不符合条件下点击执行函数</span></span><br><span class="line">    $(<span class="string">".get_code"</span>).removeAttr(<span class="string">"onclick"</span>);</span><br><span class="line"><span class="comment">// 前端检验规则</span></span><br><span class="line">    <span class="keyword">var</span> mobile = $(<span class="string">"#register_mobile"</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!mobile) &#123;</span><br><span class="line">        $(<span class="string">"#register-mobile-err"</span>).html(<span class="string">"请填写正确的手机号！"</span>);</span><br><span class="line">        $(<span class="string">"#register-mobile-err"</span>).show();</span><br><span class="line">        $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> imageCode = $(<span class="string">"#imagecode"</span>).val();</span><br><span class="line">    <span class="keyword">if</span> (!imageCode) &#123;</span><br><span class="line">        $(<span class="string">"#image-code-err"</span>).html(<span class="string">"请填写验证码！"</span>);</span><br><span class="line">        $(<span class="string">"#image-code-err"</span>).show();</span><br><span class="line">        $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 发送短信验证码</span></span><br><span class="line"><span class="comment">// 根据后端返回的json数据实现不同提示，局部刷新，要使用ajax请求</span></span><br><span class="line">    $.get(<span class="string">'/user/sms_code'</span>,&#123;</span><br><span class="line">        <span class="string">'mobile'</span>:mobile,</span><br><span class="line">        <span class="string">'imagecode'</span>:imageCode,</span><br><span class="line">    &#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.result==<span class="number">1</span>)&#123;</span><br><span class="line">            alert(<span class="string">'请填写完整数据'</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">2</span> || data.result==<span class="number">4</span>)&#123;</span><br><span class="line">            alert(<span class="string">'图形验证码错误'</span>);</span><br><span class="line">            $(<span class="string">".get_code"</span>).attr(<span class="string">"onclick"</span>, <span class="string">"sendSMSCode();"</span>);</span><br><span class="line">            generateImageCode();</span><br><span class="line">            $(<span class="string">"#imagecode"</span>).val(<span class="string">''</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(data.result==<span class="number">3</span>)&#123;</span><br><span class="line">            alert(<span class="string">'请查看手机'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于短信验证码等待60秒功能会在下文Django的框架中实现。</p><h2 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h2><p>前后端分离相比于Flas,k所以不需要再写前端代码，只要按照restful的开发格式，返回json数据即可</p><h3 id="短信验证码-1"><a href="#短信验证码-1" class="headerlink" title="短信验证码"></a>短信验证码</h3><p>djang框架实现短信验证码功能，同样使用第三方工具包云通讯功能，云通讯配置及使用方法在上述过程中已有介绍，这里就不在赘述。</p><h4 id="Django框架API接口设计"><a href="#Django框架API接口设计" class="headerlink" title="Django框架API接口设计"></a>Django框架API接口设计</h4><p>访问方式： GET /sms_codes/(?P<mobile>1[3-9]\d{9})/</mobile></p><p>请求参数： 路径参数与查询字符串参数</p><table><thead><tr><th>参数</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td><font color="#000000">mobile</font></td><td><font color="#000000">str</font></td><td><font color="#000000">是</font></td><td><font color="#000000">手机号</font></td></tr></tbody></table><p>返回数据：json</p><table><thead><tr><th>返回值</th><th>类型</th><th>是否必传</th><th>说明</th></tr></thead><tbody><tr><td><font color="#000000">message</font></td><td><font color="#000000">str</font></td><td><font color="#000000">否</font></td><td><font color="#000000">OK，发送成功</font></td></tr></tbody></table><h4 id="后端代码"><a href="#后端代码" class="headerlink" title="后端代码"></a>后端代码</h4><p>在应用的urls.py中配置路由</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(r<span class="string">'^sms_code/(?P&lt;mobile&gt;1[3-9]\d&#123;9&#125;)/$'</span>,views.SMSCodeView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在应用的views.py中定义视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class SMSCodeView(APIView):</span><br><span class="line">   </span><br><span class="line">    def get(self, request, mobile):</span><br><span class="line">        <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        接收手机号，发送短信验证码</span></span><br><span class="line"><span class="string">        :param mobile: 手机号</span></span><br><span class="line"><span class="string">        :return: 是否成功</span></span><br><span class="line"><span class="string">        '</span><span class="string">''</span></span><br><span class="line">        # 获取redis的连接</span><br><span class="line">        redis_cli = get_redis_connection(<span class="string">'verify_code'</span>)</span><br><span class="line">        # 检查是否在60s内有发送记录</span><br><span class="line">        sms_flag = redis_cli.get(<span class="string">'sms_flag_'</span> + mobile)</span><br><span class="line">        <span class="keyword">if</span> sms_flag:</span><br><span class="line">            raise serializers.ValidationError(<span class="string">'请稍候再发送短信验证码'</span>)</span><br><span class="line">        # 生成短信验证码</span><br><span class="line">        sms_code = str(random.randint(<span class="number">100000</span>, <span class="number">999999</span>))</span><br><span class="line">        # 保存短信验证码与发送记录</span><br><span class="line">        # 存验证码，300秒</span><br><span class="line">        redis_cli.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">        # 存发送标记，60秒</span><br><span class="line">        redis_cli.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        # 发送短信</span><br><span class="line">        CCP.sendTemplateSMS(mobile,sms_code,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">'message'</span>: <span class="string">'OK'</span>&#125;)</span><br></pre></td></tr></table></figure><p>用的djang的drf框架，别忘了导入各种包(response对象，redis数据库连接，APIview，云通讯，random，序列化器)</p><h4 id="关于与redis数据库交互的优化"><a href="#关于与redis数据库交互的优化" class="headerlink" title="关于与redis数据库交互的优化"></a>关于与redis数据库交互的优化</h4><p>上边代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 保存短信验证码与发送记录</span><br><span class="line">     # 存验证码，300秒</span><br><span class="line">     redis_cli.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     # 存发送标记，60秒</span><br><span class="line">     redis_cli.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>这部分代码与redis数据库交互了两次，如何进行优化，只交互一次呢？<br>采用redis管道，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 优化redis交互，减少通信的次数，管道pipeline</span><br><span class="line">     redis_pl = redis_cli.pipeline()</span><br><span class="line">     redis_pl.setex(<span class="string">'sms_code_'</span> + mobile, <span class="number">300</span>, sms_code)</span><br><span class="line">     redis_pl.setex(<span class="string">'sms_flag_'</span> + mobile, <span class="number">60</span>, <span class="number">1</span>)</span><br><span class="line">     redis_pl.execute()</span><br></pre></td></tr></table></figure><p>即可优化redis的交互次数。</p>]]></content>
    
    <summary type="html">
    
      基于Flask框架与Django框架的web开发过程中，用户注册功能如何实现图形验证码与短信验证码功能
    
    </summary>
    
      <category term="web开发" scheme="http://myLiJuXin.com/categories/web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="web,验证码" scheme="http://myLiJuXin.com/tags/web-%E9%AA%8C%E8%AF%81%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux的常用基本命令（二）</title>
    <link href="http://myLiJuXin.com/2018/08/16/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://myLiJuXin.com/2018/08/16/关于Linux的终端常用命令（二）/</id>
    <published>2018-08-16T09:39:04.000Z</published>
    <updated>2018-08-20T15:05:26.000Z</updated>
    
    <content type="html"><![CDATA[<div>接上面《关于Linux的常用基本命令（一）》</div><a href="https://zypuu.github.io/2018/08/15/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="noopener">点这里</a><br><br>#### 管道命令<br><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【命令1】 | 【命令2】 # 命令1的输出结果作为命令2的输入</span><br></pre></td></tr></table></figure><br><br>#### 查找某个文件的文本<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep 【选项】 “字符串”  【文件】</span><br><span class="line">选项：-i 忽略大小写</span><br><span class="line">  -n 显示匹配行及行号</span><br><span class="line">  -v 取反（显示余下的信息）</span><br></pre></td></tr></table></figure><br><br><div>例： ps -aux | grep ’mysql‘ 查看运行中的进程，带有mysql的进程</div><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find 【路径】 【选项】</span><br><span class="line">选项：-name ’字符串‘ # 查找该文件名的文件</span><br><span class="line">           -size +（-）’大小‘ # 查找文件大于（小于）多少的文件</span><br><span class="line">   -permission 权限 # 查找拥有该权限的文件</span><br></pre></td></tr></table></figure><h4 id="tar打包压缩文件与解压缩"><a href="#tar打包压缩文件与解压缩" class="headerlink" title="tar打包压缩文件与解压缩"></a>tar打包压缩文件与解压缩</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar 【选项】【打包后的文件名】【 要打包的文件名】</span><br><span class="line">选项： -c 生成打包文件</span><br><span class="line">-v 显示进度</span><br><span class="line">-f 指定打包文件名称，所以f选项要放最后</span><br><span class="line">-x 拆包解包</span><br><span class="line">-z gzip格式压缩解压</span><br><span class="line">-j bzip2格式压缩解压</span><br><span class="line">c 指定目录</span><br></pre></td></tr></table></figure><h4 id="gzip格式压缩解压"><a href="#gzip格式压缩解压" class="headerlink" title="gzip格式压缩解压"></a>gzip格式压缩解压</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gizp 【文件名】 # 压缩文件</span><br><span class="line">gzip -d 【文件名】 # 解压缩文件</span><br></pre></td></tr></table></figure><h4 id="查看命令位置"><a href="#查看命令位置" class="headerlink" title="查看命令位置"></a>查看命令位置</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which</span><br></pre></td></tr></table></figure><h4 id="查看当前用户登录"><a href="#查看当前用户登录" class="headerlink" title="查看当前用户登录"></a>查看当前用户登录</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who # tty 本地登录 pts 远程登录</span><br></pre></td></tr></table></figure><h4 id="授权当前用户执行命令"><a href="#授权当前用户执行命令" class="headerlink" title="授权当前用户执行命令"></a>授权当前用户执行命令</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo # 管理员权限</span><br></pre></td></tr></table></figure><h4 id="退出终端，回到上一用户，退出远程"><a href="#退出终端，回到上一用户，退出远程" class="headerlink" title="退出终端，回到上一用户，退出远程"></a>退出终端，回到上一用户，退出远程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><h4 id="软件卸载与安装"><a href="#软件卸载与安装" class="headerlink" title="软件卸载与安装"></a>软件卸载与安装</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install “安装包” # 安装</span><br><span class="line">sudo apt-get remove “安装包” # 删除</span><br><span class="line">sudo apt-get update “安装包” # 更新</span><br></pre></td></tr></table></figure><h4 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now （或加时间） # 立即关机，或者多少时间后关机</span><br><span class="line">-r # 重启</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      关于linux系统ubantu终端的一些常用命令整理
    
    </summary>
    
      <category term="Linux" scheme="http://myLiJuXin.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://myLiJuXin.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux终端的常用命令（一）</title>
    <link href="http://myLiJuXin.com/2018/08/15/%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://myLiJuXin.com/2018/08/15/关于Linux的终端常用命令（一）/</id>
    <published>2018-08-15T11:15:15.000Z</published>
    <updated>2018-08-17T04:33:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><hr><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux由Unix发展而来，于1991年林纳斯（linus）发布，分为内核与发行版，内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，主要做一些基本的，也是重要的操作。比如进程管理、内存管理、磁盘管理、驱动管理、电源管理、安全管理等。<br>Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环。<br>稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序<br>开发版：由于要试验各种解决方案，所以变化很快<br>内核源码网址：<a href="http://www.kernel.org" target="_blank" rel="noopener">点这里</a><br></div><br><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux发行版通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。<br><br>主要有：ubantu，centos，redhat, debian等，这里主要是ubantu的基本常用命令。<br></div><br>### Linux终端命令基本使用<br>———-<br><div>终端命令格式：Command 【-options（选项，可以配合使用）】【parameter（对象）】</div><h4 id="1-查看文件信息（在当前路径下输入即可查看当前路径文件）"><a href="#1-查看文件信息（在当前路径下输入即可查看当前路径文件）" class="headerlink" title="1. 查看文件信息（在当前路径下输入即可查看当前路径文件）"></a>1. 查看文件信息（在当前路径下输入即可查看当前路径文件）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ls -l # 查看详情</span><br><span class="line">ls -a # 查看所有文件</span><br><span class="line">ls -h # 配合-l显示文件大小</span><br></pre></td></tr></table></figure><h4 id="2-通配符，可以代替字符"><a href="#2-通配符，可以代替字符" class="headerlink" title="2. 通配符，可以代替字符"></a>2. 通配符，可以代替字符</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* # 代表0个或多个任意字符</span><br><span class="line">？ # 代表任意一个字符</span><br></pre></td></tr></table></figure><h4 id="3-清屏"><a href="#3-清屏" class="headerlink" title="3. 清屏"></a>3. 清屏</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br><span class="line">按键：ctrl +L</span><br></pre></td></tr></table></figure><h4 id="4-切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（-）开始）"><a href="#4-切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（-）开始）" class="headerlink" title="4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）"></a>4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ./Desktop # .代表当前路径</span><br><span class="line">cd ../ # ..代表上一级路径</span><br></pre></td></tr></table></figure><h4 id="5-显示当前绝对路径"><a href="#5-显示当前绝对路径" class="headerlink" title="5. 显示当前绝对路径"></a>5. 显示当前绝对路径</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure><h4 id="6-创建目录"><a href="#6-创建目录" class="headerlink" title="6. 创建目录"></a>6. 创建目录</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir 目录名</span><br><span class="line">mkdir a/b/c -p # 创建级联目录</span><br></pre></td></tr></table></figure><h4 id="7-创建文件（文件名指定后缀名）"><a href="#7-创建文件（文件名指定后缀名）" class="headerlink" title="7. 创建文件（文件名指定后缀名）"></a>7. 创建文件（文件名指定后缀名）</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch 文件名</span><br><span class="line">touch 文件1 文件2 文件3 # 创建多个文件</span><br></pre></td></tr></table></figure><h4 id="8-删除文件，目录"><a href="#8-删除文件，目录" class="headerlink" title="8. 删除文件，目录"></a>8. 删除文件，目录</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -i # 删除文件给予交互提示</span><br><span class="line">rm -f # 强制删除</span><br><span class="line">rm -r # 递归删除，删除目录</span><br></pre></td></tr></table></figure><h4 id="9-拷贝文件，目录"><a href="#9-拷贝文件，目录" class="headerlink" title="9. 拷贝文件，目录"></a>9. 拷贝文件，目录</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cp 【源文件名】【目标目录路径】# 拷贝文件不能在本目录下，不能重名</span><br><span class="line">例： cp <span class="number">1.</span>txt ./a 将<span class="number">1.</span>txt复制到当前目录的a目录下</span><br><span class="line">cp 【源文件名】【目标文件名】# 拷贝并重命名</span><br><span class="line">例： cp a.txt b.txt 复制a并命名为b</span><br><span class="line">选项： -r 拷贝文件夹  -f 强制拷贝 -i交互提示</span><br></pre></td></tr></table></figure><h4 id="10-移动文件，文件夹"><a href="#10-移动文件，文件夹" class="headerlink" title="10. 移动文件，文件夹"></a>10. 移动文件，文件夹</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv 【源文件名】【移动目标路径】# 移动目录不用-r 例：mv 1.txt ./a 将1文件移动到当前目录的a目录下</span><br><span class="line">mv 【源文件名】【移动后文件名】# 重命名，不能重名 例： mv a.py b.py</span><br></pre></td></tr></table></figure><h4 id="11-树状显示目录"><a href="#11-树状显示目录" class="headerlink" title="11. 树状显示目录"></a>11. 树状显示目录</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure><h4 id="12-查看历史命令"><a href="#12-查看历史命令" class="headerlink" title="12. 查看历史命令"></a>12. 查看历史命令</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history # 显示历史命令</span><br><span class="line">！数字 # 引用某一行命令 例：！20，引用20行命令</span><br></pre></td></tr></table></figure><h4 id="13-查看，写入文件内容"><a href="#13-查看，写入文件内容" class="headerlink" title="13. 查看，写入文件内容"></a>13. 查看，写入文件内容</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat 【文件名】 # 查看 例：cat 1.txt</span><br><span class="line">gedit 【文件名】# 写入 例 ： gedit 1.txt</span><br></pre></td></tr></table></figure><h4 id="14-重定向（将命令执行结果保存到另一个文件中）"><a href="#14-重定向（将命令执行结果保存到另一个文件中）" class="headerlink" title="14. 重定向（将命令执行结果保存到另一个文件中）"></a>14. 重定向（将命令执行结果保存到另一个文件中）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; # 覆盖</span><br><span class="line">&gt;&gt; # 追加 </span><br><span class="line">例： cat <span class="number">1.</span>txt <span class="number">2.</span>txt &gt; <span class="number">3</span>,txt 将<span class="number">1</span>,<span class="number">2</span>两个文件的内容重定向到<span class="number">3</span>里，<span class="number">3.</span>txt不存在则创建</span><br></pre></td></tr></table></figure><h4 id="15-分屏显示内容"><a href="#15-分屏显示内容" class="headerlink" title="15. 分屏显示内容"></a>15. 分屏显示内容</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more # 分屏显示文件内容，一般接到其他命令后，空格切换屏幕</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      关于linux系统ubantu终端的一些常用命令整理
    
    </summary>
    
      <category term="Linux" scheme="http://myLiJuXin.com/categories/Linux/"/>
    
    
      <category term="Linux命令" scheme="http://myLiJuXin.com/tags/Linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://myLiJuXin.com/2018/08/14/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://myLiJuXin.com/2018/08/14/我的第一篇博客/</id>
    <published>2018-08-14T14:01:40.000Z</published>
    <updated>2018-08-17T04:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><div><br>        学习编程之后，逐渐在这一领域有了一定的了解，在CSDN博客上看各种大神写的文章，那些未知的技术，引起了我的求知欲，同时看着别人炫酷的博客，也让我有了一个搭建自己的博客网站的想法，来对自己学过的知识，进行总结梳理，于是开始了我的博客之旅。<br></div><h4 id="1-搭建自己的博客网站需要耐心"><a href="#1-搭建自己的博客网站需要耐心" class="headerlink" title="1.搭建自己的博客网站需要耐心"></a>1.搭建自己的博客网站需要耐心</h4><div><br>        对于我这种博客小白来说，搭建自己的个人博客，着实费了一番功夫，经过大约一周时间的研究学习，查阅各种资料，解决各种bug，尝试不同的主题效果，终于搭建好我自己的个人博客网站，可以开始写自己的第一篇博客文章，此刻我的心情是非常激动的，毕竟这大约一周时间的努力，取得了一定的成果，效果还比较满意，不过还要继续完善。<br>        总的来说，过程非常繁琐，需要耐心，网上教程都很详细，一步步按照教程走即可，但是过程中有些细节需要综合自己的实际情况来定，不然会出一些难解决的bug，所以要懂一些js，css知识的原理。我用的是github+hexo搭建的，个人认为比较简单吧，也研究过ruby，jkelly那些方法，不过没安装上环境，就换了hexo，有兴趣的可以好好研究下。<br></div><h4 id="2-IT知识研究领域"><a href="#2-IT知识研究领域" class="headerlink" title="2. IT知识研究领域"></a>2. IT知识研究领域</h4><div><br>        我主要学习的是Python，所以我的博客内容主要围绕着python来展开的，当然这只是一种编写程序的语言方式，所以本质上还是编程以及相关内容，比如Linux，web开发，框架，算法，爬虫，人工智能等，我个人对人工智能非常感兴趣，所以也会慢慢往这个方向去靠近，机器学习，神经网络等，自己慢慢研究学习吧。<br></div>        <h4 id="3-写博客文章的一些基本格式与上传命令"><a href="#3-写博客文章的一些基本格式与上传命令" class="headerlink" title="3. 写博客文章的一些基本格式与上传命令"></a>3. 写博客文章的一些基本格式与上传命令</h4><div><br>        为了以后方便写博客，对于我这个博客小白，还是有必要在这里对于一些文章相关格式及命令，进行总结的。<br>        通过github+hexo搭建好博客后，如何创建一篇新博客呢<br>        在搭建博客的时候，会安装git软件，在根目录下打开git，通过git命令来执行，新建一篇博客：<br></div><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="string">"你的博客的名称"</span></span><br></pre></td></tr></table></figure><br><br><div><br>    然后在根目录文件夹下source/_posts下新生成一个md文件，名称就是你自己起的名字，打开就可以开始写博客啦，要用markdown语法写，所以要提前准备一款编辑器，我个人用的是小书匠编辑器，还不错。<br>    文章的一些格式属性有以下几种可以自己设置：<br></div><br><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 文章标题</span><br><span class="line">date:  创建时间，这里可以随意修改</span><br><span class="line">categories:  文章分类目录，可以为空</span><br><span class="line"><span class="keyword">tags:</span> 文章标签，可空，多标签请用格式[tag1,tag2,tag3]</span><br><span class="line">description: 对本页的描述，相当于是一个简介，如果这个定义了，就会在首页中出现这里的内容而不会出现整个文章详细内容。</span><br></pre></td></tr></table></figure><br><br><div><br>     然后下面就可以开始写文章了，写完即可通过git上传了<br>    </div> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><div><br>     即可部署到github上。<br></div><h4 id="4-开启博客之旅"><a href="#4-开启博客之旅" class="headerlink" title="4.开启博客之旅"></a>4.开启博客之旅</h4><div><br>        以前的学习笔记都记录在本子上，或者其他文档里，之后将会慢慢整理在自己的博客上，来完善自己的学习体系，同时搭建自己的博客，让自己的博客更炫酷。<br></div>]]></content>
    
    <summary type="html">
    
      个人初建博客的一些随笔以及写文章的属性格式等
    
    </summary>
    
      <category term="随笔" scheme="http://myLiJuXin.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="第一篇" scheme="http://myLiJuXin.com/tags/%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    
  </entry>
  
</feed>
