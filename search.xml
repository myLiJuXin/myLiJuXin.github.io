<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于数据库redis与Mysql的区别以及在web开发中的配合使用]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[传统型关系数据库Mysql的瓶颈在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。 Nosql与redisNoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。 Nosql的优势易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。 redisRedis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 结论NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。 利用redis做mysql的缓存前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。 缓存 页面缓存经常用在CMS(content manage system)内存管理系统里面。数据缓存经常会用在页面的具体数据里面。 Redis缓存原理采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。 对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。 Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。 用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。 redis中的hash python中的字典 key 对象 field key value value 即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,redis,mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java单例和多例了解]]></title>
    <url>%2F2017%2F08%2F24%2Fjava%E5%8D%95%E4%BE%8B%E5%92%8C%E5%A4%9A%E4%BE%8B%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一.什么是单例,多例?所谓单例就是所有的请求都用一个对象（实例）来处理，比如我们常用的service和dao层的对象通常都是单例的，而多例则指每个请求用一个新的对象（实例）来处理，比如action. 单例模式的关键有两点：1.构造方法为私有，这样外界就不能随意调用。2.get的方法为静态，由类直接调用 多例模式（Multiton）1 、多例类可以有多个实例2 、多例类必须能够自我创建并管理自己的实例，并向外界提供自己的实例。 单例模式和多例模式说明： 单例模式和多例模式属于对象模式。 单例模式的对象在整个系统中只有一份，多例模式可以有多个实例。 它们都不对外提供构造方法，即构造方法都为私有。扩展:单例具体写法二. 如何产生单例多例？在通用的SSM中，单例在spring中是默认的，如果要产生多例，则在配置文件的bean中添加scope=”prototype”或者使用注解@Scope在对应类上声明.三. spring中创建bean对象时多例和单例的区别123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt; &lt;!-- init-method * 该方法是由spring容器执行 * 在构造函数之后执行 * 如果在构造函数之后，在调用方法之前要做一些工作，可以在init方法中完成 destroy-method * 如果该bean是单例(默认就是singlton)，则在spring容器关闭或者销毁的时候，执行该方法 * 如果该bean是多例(scope="prototype")，则spring容器不负责销毁 说明：要想让spring容器控制bean的生命周期，那么该bean必须是单例 如果该bean是多例，该bean中还有资源，关闭资源的操作由程序员完成 --&gt; &lt;bean id="helloWorld" class="cn.edu.initdestroy.HelloWorld" scope="prototype" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt;&lt;/beans&gt; 注意： 当一个bean是多例模式的情况下，lazy-init为false或者default无效。123456789101112&lt;!-- 在默认情况下，spring创建bean是单例模式 scope singleton 默认 单例 属性是共享的 一般情况下，把数据存放在方法中的变量中 prototype 多例 当一个bean是多例模式的情况下，lazy-init为false或者default无效--&gt;&lt;bean id="helloWorld" class="cn.itcast.spring0909.scope.HelloWorld" scope="prototype" lazy-init="false"&gt;&lt;/bean&gt; 12345678910111213141516171819&lt;!-- 在启动spring容器的时候，spring容器配置文件中的类就已经创建完成对象了 lazy-init default 即为 false true 在context.getBean的时候才要创建对象 * 优点 如果该bean中有大数据存在，则什么时候context.getBean,什么时候创建对象 可以防止数据过早的停留在内存中，做到了懒加载 * 缺点 如果spring配置文件中，该bean的配置有错误，那么在tomcat容器启动的时候，发现不了 false 在启动spring容器的时候创建对象 * 优点 如果在启动tomcat时要启动spring容器， 那么如果spring容器会错误，这个时候tomcat容器不会正常启动 * 缺点 如果存在大量的数据，会过早的停留在内存中--&gt;&lt;bean id="helloWorld" class="cn.edu.spring0909.createobject.when.HelloWorl" lazy-init="true"&gt;&lt;/bean&gt;&lt;bean id="person" class="cn.edu.spring0909.createobject.when.Person" lazy-init="true"&gt;&lt;/bean&gt; 四. 为什么要用单例多例？之所以用单例，是因为没必要每个请求都新建一个对象，这样子既浪费CPU又浪费内存；之所以用多例，是为了防止并发问题；即一个请求改变了对象的状态，此时对象又处理另一个请求，而之前请求对对象状态的改变导致了对象对另一个请求做了错误的处理； 五. 什么时候用单例，什么时候用多例？用单例和多例的标准只有一个：当对象含有可改变的状态时（更精确的说就是在实际应用中该状态会改变），则多例，否则单例；另外要说一下，并不是说service或dao一定是单例，标准同第四点所讲的，就曾见过有的service中也包含了可改变的状态，同时执行方法也依赖该状态，但一样用的单例，这样就会出现隐藏的BUG,而并发的BUG通常很难重现和查找.]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例,基础,多例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中耦合解耦内聚相关了解]]></title>
    <url>%2F2017%2F05%2F25%2Fjava%E4%B8%AD%E8%80%A6%E5%90%88%E8%A7%A3%E8%80%A6%E5%86%85%E8%81%9A%E7%9B%B8%E5%85%B3%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一.程序的耦合关系以及解耦的方式1.耦合与解耦的概念耦合: 在软件工程中，对象之间的耦合度就是对象之间的依赖性。对象之间的耦合越高，维护成本越高，因此对象的设计应使类和构件之间的耦合最小解耦:在软件工程中，降低耦合度即可以理解为解耦，模块间有依赖关系必然存在耦合，理论上的绝对零耦合是做不到的，但可以通过一些现有的方法将耦合度降至最低 2.程序中存在的耦合关系与解耦的方式2.1 耦合简单的例子:123456789public class A&#123; public int i;&#125;public class B&#123; public void put(A a)&#123; System.out.println(a.i); &#125;&#125; 以上代码就属于强耦合,B类中方法put要执行必须需要A类中的int属性i,缺了A,B中方法就不能执行 2.2 使用面向接口的编程方式实现上面例子的解耦:12345678910111213141516171819202122232425 public interface IBase&#123; void say();&#125;public class A implements IBase&#123; @Override public void say() &#123; System.out.println("I am A"); &#125;&#125;public class B implements IBase&#123; @Override public void say() &#123; System.out.println("I am B"); &#125;&#125;public class C&#123; public void put(IBase base)&#123; base.say(); &#125;&#125; 这只是其中的一种情况 2.3 根据耦合程度分类总结：耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。 2.4 解耦解耦的本质就是将类之间的直接关系转换成间接关系，不管是类向上转型还是接口回调都是在类之间加了一层，将原来的直接关系变成间接关系，使得两类对中间层是强耦合，两类之间变成弱耦合关系。 （a）采用现有设计模式实现解耦，如事件驱动模式、观察者模式、责任链模式等都可以达到解耦的目的；（b）采用面向接口的方式编程，而不是用直接的类型引用，除非在最小内聚单元内部。但使用该方法解耦需要注意不要滥用接口。（c）高内聚，往往会带来一定程度的低耦合度。高内聚决定了内部自行依赖，对外只提供必须的接口或消息对象，那么由此即可达成较低的耦合度。 ( d )注解，以注解的方式，将方法，属性注入依赖，实现高扩展性。 解耦总的一句话来说，减少依赖，抽象业务和逻辑，让各个功能实现独立。 2.5 内聚与耦合内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。]]></content>
      <categories>
        <category>概念</category>
      </categories>
      <tags>
        <tag>耦合,解耦</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux的常用基本命令（二）]]></title>
    <url>%2F2017%2F04%2F23%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上面《关于Linux的常用基本命令（一）》点这里#### 管道命令1【命令1】 | 【命令2】 # 命令1的输出结果作为命令2的输入#### 查找某个文件的文本1234grep 【选项】 “字符串” 【文件】选项：-i 忽略大小写 -n 显示匹配行及行号 -v 取反（显示余下的信息）例： ps -aux | grep ’mysql‘ 查看运行中的进程，带有mysql的进程 查找文件1234find 【路径】 【选项】选项：-name ’字符串‘ # 查找该文件名的文件 -size +（-）’大小‘ # 查找文件大于（小于）多少的文件 -permission 权限 # 查找拥有该权限的文件 tar打包压缩文件与解压缩12345678tar 【选项】【打包后的文件名】【 要打包的文件名】选项： -c 生成打包文件 -v 显示进度 -f 指定打包文件名称，所以f选项要放最后 -x 拆包解包 -z gzip格式压缩解压 -j bzip2格式压缩解压 c 指定目录 gzip格式压缩解压12gizp 【文件名】 # 压缩文件gzip -d 【文件名】 # 解压缩文件 查看命令位置1which 查看当前用户登录1who # tty 本地登录 pts 远程登录 授权当前用户执行命令1sudo # 管理员权限 退出终端，回到上一用户，退出远程1exit 软件卸载与安装123sudo apt-get install “安装包” # 安装sudo apt-get remove “安装包” # 删除sudo apt-get update “安装包” # 更新 关机重启12shutdown -h now （或加时间） # 立即关机，或者多少时间后关机 -r # 重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux终端的常用命令（一）]]></title>
    <url>%2F2017%2F04%2F21%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux由Unix发展而来，于1991年林纳斯（linus）发布，分为内核与发行版，内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，主要做一些基本的，也是重要的操作。比如进程管理、内存管理、磁盘管理、驱动管理、电源管理、安全管理等。Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环。稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序开发版：由于要试验各种解决方案，所以变化很快内核源码网址：点这里&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux发行版通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。主要有：ubantu，centos，redhat, debian等，这里主要是ubantu的基本常用命令。### Linux终端命令基本使用———-终端命令格式：Command 【-options（选项，可以配合使用）】【parameter（对象）】 1. 查看文件信息（在当前路径下输入即可查看当前路径文件）123ls -l # 查看详情ls -a # 查看所有文件ls -h # 配合-l显示文件大小 2. 通配符，可以代替字符12* # 代表0个或多个任意字符？ # 代表任意一个字符 3. 清屏12clear按键：ctrl +L 4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）12cd ./Desktop # .代表当前路径cd ../ # ..代表上一级路径 5. 显示当前绝对路径1pwd 6. 创建目录12mkdir 目录名mkdir a/b/c -p # 创建级联目录 7. 创建文件（文件名指定后缀名）12touch 文件名touch 文件1 文件2 文件3 # 创建多个文件 8. 删除文件，目录123rm -i # 删除文件给予交互提示rm -f # 强制删除rm -r # 递归删除，删除目录 9. 拷贝文件，目录12345cp 【源文件名】【目标目录路径】# 拷贝文件不能在本目录下，不能重名例： cp 1.txt ./a 将1.txt复制到当前目录的a目录下cp 【源文件名】【目标文件名】# 拷贝并重命名例： cp a.txt b.txt 复制a并命名为b选项： -r 拷贝文件夹 -f 强制拷贝 -i交互提示 10. 移动文件，文件夹12mv 【源文件名】【移动目标路径】# 移动目录不用-r 例：mv 1.txt ./a 将1文件移动到当前目录的a目录下mv 【源文件名】【移动后文件名】# 重命名，不能重名 例： mv a.py b.py 11. 树状显示目录1tree 12. 查看历史命令12history # 显示历史命令！数字 # 引用某一行命令 例：！20，引用20行命令 13. 查看，写入文件内容12cat 【文件名】 # 查看 例：cat 1.txtgedit 【文件名】# 写入 例 ： gedit 1.txt 14. 重定向（将命令执行结果保存到另一个文件中）123&gt; # 覆盖&gt;&gt; # 追加 例： cat 1.txt 2.txt &gt; 3,txt 将1,2两个文件的内容重定向到3里，3.txt不存在则创建 15. 分屏显示内容1more # 分屏显示文件内容，一般接到其他命令后，空格切换屏幕]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring基于注解的IOC配置]]></title>
    <url>%2F2016%2F11%2F24%2Fspring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84IOC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[一.为什么要用注解spring 注解可以减少xml配置； 注释配置相对于 XML 配置具有很多的优势： 它可以充分利用 Java 的反射机制获取类结构信息，这些信息可以有效减少配置的工作。如使用 JPA 注释配置 ORM 映射时，我们就不需要指定 PO 的属性名、类型等信息，如果关系表字段和 PO 属性名、类型都一致，您甚至无需编写任务属性映射信息——因为这些信息都可以通过 Java 反射机制获取。 注释和 Java 代码位于一个文件中，而 XML 配置采用独立的配置文件，大多数配置信息在程序开发完成后都不会调整，如果配置信息和 Java 代码放在一起，有助于增强程序的内聚性。而采用独立的 XML 配置文件，程序员在编写一个功能时，往往需要在程序文件和配置文件中不停切换，这种思维上的不连贯会降低开发效率。 二.环境配置基于注解的IOC配置共有两种：1.依赖于xml文件中context标签的配置。配置方法：在spring的配置文件中开启spring对注解ioc的支持123456789101112&lt;!--导入约束--&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;&lt;!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --&gt;&lt;!--开启包扫描--&gt;&lt;context:component-scan base-package="cn.itcast"/&gt; 获取容器：1ApplicationContext ac = new ClassPathXmlApplicationContext("配置文件全名称"); 2.纯注解配置可以完全脱离xml文件配置方法：在一个类上编写两个标签。12@Configuration//表明当前类是一个配置类@ComponentScan(basePackages = "配置要扫描的包") 获取容器：1ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);//参数为配置类的字节码文件 三.常用注解1.创建对象(4个)创建对象交给spring管理的注解1234567//配置到实现类上@Component //其他如工具类@Controller //web层@Service //service层@Repository //dao层 //默认创建对象的唯一标识：当前类名首字母小写 //value : 创建对象的唯一标识在注解后加("唯一标识") 2.依赖注入(4个)依赖关系：配置依赖关系到注解将注解配置到依赖关系的属性上（set方法可以省略）或者set方法上12345678910111213@Autowired //自动装载（自动赋值） //1.按照类型（接口类型）从容器中查找对象，并注入（赋值） //2.按照属性名称作为唯一标识从容器中查找对象，并注入@Qualifier //配合@Autowired一起使用 //按照指定的唯一标识，从容器中查找对象并注入@Resource //jdk提供的依赖注入的注解//name：唯一标识//根据唯一标识从容器中获取对象并注入 @value //配置属性上 //1.注入基本数据类型的 //**2.注入被spring容器管理的properties文件中的内容 //使用@value结合spring-el表达式获取properties文件中的内容 //语法：@Value(value="$&#123;properties文件中的key&#125;") 3.生命周期(3个)对象生命周期的注解12345678910111213141516//1.对象作用域@Scope //配置到类上 //singleton：单例(默认值) //prototype：多例//2.初始化方法:对象创建之后立即执行的方法//替换xml中init-method@PostConstructpublic void init() &#123; System.out.println("执行初始化方法");&#125;//3.销毁方法:和对象的作用域有关（singleton有效）：容器关闭，对象销毁执行的方法//替换xml中destory-method@PreDestroypublic void destory() &#123; System.out.println("执行销毁方法");&#125; 4.纯注解开发所用的注解spring的配置类：替换xml中配置信息123456789101112131415//1.声明配置类(创建对象交给spring容器管理)//创建对象交给spring容器管理 | 告诉spring容器@Configuration//2.开启包扫描@ComponentScan(basePackages = "包路径")//3.将properties配置文件交给spring容器管理@PropertySource(value = "classpath:文件名称")@Bean//需要配置到方法上，此方法需要一个返回值//表明：将此方法的返回值交给spring容器管理//执行：spring容器创建的过程中，会扫描所有的@Bean注解//执行当前注解配置的方法，得到返回值，将返回值存入spring容器//name:唯一标识()@Import //引入其他配置类 //value：其他配置类的字节码对象 5.spring整合Junit测试1234//1.指定spring提供的单元测试环境@RunWith(SpringJUnit4ClassRunner.class)//2.指定spring容器的配置信息@ContextConfiguration(classes = SpringConfig.class) 注：整合junit是基于junit的，只有编译运行@Test，整合的注解才会执行替换原有的运行器。 四.使用注解结合xml方式完成CRUD不做说明详见demo02 五.使用纯注解方式完成CRUD不做说明详见demo03]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>注解,IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring框架入门学习]]></title>
    <url>%2F2016%2F11%2F23%2Fspring%E6%A1%86%E6%9E%B6%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[一.spring中的解耦方式IOCIOC 控制反转-Inversion Of Control它的作用:减弱程序中的耦合也就是降低代码的依赖关系将创建对象的权利交给框架它的核心思想就是:1.通过读取解析配置文件反射创建对象2.将对象保存在一个容器内,供使用者调用这里面要解释两个问题：第一个：存哪去？为了方便取出使用,应用map集合来装对象,因为map的key=value模式可以很方便的定位到所需要的对象第二个： 什么是工厂？工厂就是帮我们从容器中获得指定对象的类,此时我们的获取方式已经发生了改变,从原本的自己创建变成了现在的通过类查找被动获取.这种被动获取对象的方式就是控制反转的思想 二.spring的体系结构spring5的结构体系图如下:详细信息参考:Spring5 系统架构 三.spring的依赖注入spring的XML基础配置以及对象配置方式点击显示或隐藏 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- beans xmlns:xml namespace （标签） xsd约束地址--&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 方式一（重要）：反射 bean : 创建对象交给spring容器管理 id: 唯一标识 class：实现类的全限定类名 scope ： 创建对象的作用域 singleton ：单例（创建单例对象），随着容器的创建而创建，随着容器的关闭自动垃圾回收 ：默认值 prototype ：多例（多例对象），调用一次getBean方法，创建一个对象 request ：创建对象存入request域中 session ：创建对象存入session域中 init-method （执行的方法名）: 指定初始化方法（创建对象之后，立即执行的方法） destroy-method （执行的方法名） ： 指定销毁方法（容器关闭对象销毁：scope必须为singleton）：对象销毁之前执行的方法 --&gt; &lt;bean id="accountService" init-method="init" destroy-method="destory" scope="prototype" class="cn.itcast.service.impl.AccountServiceImpl"&gt;&lt;/bean&gt; &lt;!--方式二：静态工厂--&gt; &lt;bean id="accountService1" class="cn.itcast.utils.AccountServiceFactory" factory-method="getAccountService"&gt;&lt;/bean&gt; &lt;!--方式三；实例化工厂 --&gt; &lt;!--创建工厂--&gt; &lt;bean id="accountServiceFactory" class="cn.itcast.utils.AccountServiceFactory1"&gt;&lt;/bean&gt; &lt;!--通过实例化工厂创建accoutService--&gt; &lt;bean id="accountService2" factory-bean="accountServiceFactory" factory-method="getAccountService"&gt;&lt;/bean&gt;&lt;/beans&gt; 依赖注入（Dependency Injection, DI）1.构造注入点击显示或隐藏 123456789101112131415161718192021222324252627282930313233&lt;!--创建UserServiceImpl交给spring容器中管理--&gt;&lt;bean id="UserService" class="cn.itcast.service.impl.UserServiceImpl"&gt; &lt;!-- 使用构造方法注入数据 ： 调用有参构造 constructor-arg: 构造方法参数 index: 根据构造方法中参数的索引 name: 根据构造方法中参数的名称 type: 根据构造方法中参数的类型 *** 以上三个属性是用于定位构造方法中参数的 value： 注入基本数据类型的数据 ref： 注入被spring容器管理的bean对象 *** 以上两个属性是对构造方法中参数赋值 --&gt; &lt;constructor-arg index="0" ref="UserDaoImpl"/&gt; &lt;constructor-arg index="1" value="测试数据"/&gt; &lt;constructor-arg index="2" value="1"/&gt; &lt;constructor-arg index="3"&gt; &lt;map&gt; &lt;entry key="测试数据1" value="1"/&gt; &lt;entry key="测试数据2" value="2"/&gt; &lt;/map&gt; &lt;/constructor-arg&gt; &lt;constructor-arg index="4"&gt; &lt;list value-type="java.lang.String"&gt; &lt;value&gt;测试数据1&lt;/value&gt; &lt;value&gt;测试数据2&lt;/value&gt; &lt;value&gt;测试数据3&lt;/value&gt; &lt;/list&gt; &lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!--创建UserDaoImpl交给spring容器中管理--&gt;&lt;bean name="UserDaoImpl" class="cn.itcast.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; 2.set注入点击显示或隐藏 123456789101112131415161718192021222324252627&lt;!--创建UserServiceImpl交给spring容器中管理--&gt;&lt;bean id="UserService" class="cn.itcast.service.impl.UserServiceImpl"&gt; &lt;!--property :使用set方法注入 name: 定位set方法（set方法后面的部分，首字母小写） username = setUsername（） == 反射执行 value: 注入基本数据类型的数据 ref: 注入被spring容器管理的bean对象 --&gt; &lt;property name="userDao" ref="UserDaoImpl"/&gt; &lt;property name="name" value="王者"/&gt; &lt;property name="age" value="12"/&gt; &lt;property name="beans"&gt; &lt;map&gt; &lt;entry key="王者" value="12"/&gt; &lt;entry key="吃鸡" value="15"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;王者&lt;/value&gt; &lt;value&gt;持戒&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!--创建UserDaoImpl放入spring容器中管理--&gt;&lt;bean name="UserDaoImpl" class="cn.itcast.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt; 3.p组件注入(依赖set)点击显示或隐藏 123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--使用p组件需要导入约束xmlns:p="http://www.springframework.org/schema/p"--&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!--创建UserServiceImpl交给spring容器中管理--&gt; &lt;bean id="UserService" class="cn.itcast.service.impl.UserServiceImpl" p:userDao-ref="UserDaoImpl" p:name="李" p:age="21"&gt; &lt;!--本质也是使用的set,不过是简写形式--&gt; &lt;property name="userDao" ref="UserDaoImpl"/&gt; &lt;property name="name" value="王者"/&gt; &lt;property name="age" value="12"/&gt; &lt;property name="beans"&gt; &lt;map&gt; &lt;entry key="王者" value="12"/&gt; &lt;entry key="吃鸡" value="15"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="list"&gt; &lt;list&gt; &lt;value&gt;王者&lt;/value&gt; &lt;value&gt;持戒&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建UserDaoImpl放入spring容器中管理--&gt; &lt;bean name="UserDaoImpl" class="cn.itcast.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;&lt;/beans&gt; 四.使用xml方式完成CRUD1.前期准备创建maven工程如下图 创建pojo类pojo代码点击显示或隐藏 12345678910111213141516171819202122232425262728293031323334353637383940public class Account &#123; private Integer id; private String name; private float money; @Override public String toString() &#123; final StringBuilder sb = new StringBuilder("Account&#123;"); sb.append("id=").append(id); sb.append(", name='").append(name).append('\''); sb.append(", money=").append(money); sb.append('&#125;'); return sb.toString(); &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getMoney() &#123; return money; &#125; public void setMoney(float money) &#123; this.money = money; &#125;&#125; 创建业务层接口和实现类service接口代码点击显示或隐藏 12345678910111213141516171819202122public interface AccountService &#123; /** * 添加 */ void save(Account account); /** * 根据用户id删除用户 */ void delete(int id); /** * 根据用户名更新money */ void update(Account account); /** * 根据id查找对应用户 */ Account findByName(String name);&#125; service实现类代码点击显示或隐藏 1234567891011121314151617181920212223242526272829303132333435363738public class AccountServiceImpl implements AccountService &#123; //声明accountDao private AccountDao accountDao; //accountDao的set方法 供依赖注入 public void setAccountDao(AccountDao accountDao) &#123; this.accountDao = accountDao; &#125; /** * 添加 */ public void save(Account account) &#123; accountDao.save(account); &#125; /** * 根据用户id删除用户 */ public void delete(int id) &#123; accountDao.delete(id); &#125; /** * 根据用户名更新money */ public void update(Account account) &#123; accountDao.update(account); &#125; /** * 根据id查找对应用户 */ public Account findByName(String name) &#123; return accountDao.findByName(name); &#125;&#125; 创建持久层接口和实现类dao接口代码点击显示或隐藏 12345678910111213141516171819202122public interface AccountDao &#123; /** * 添加 */ void save(Account account); /** * 根据用户id删除用户 */ void delete(int id); /** * 根据用户名更新money */ void update(Account account); /** * 根据id查找对应用户 */ Account findByName(String name);&#125; dao实现类代码点击显示或隐藏 12345678910111213141516171819202122232425262728293031323334353637383940public class AccountDaoImpl implements AccountDao &#123; //声明jdbcTemplate private JdbcTemplate jdbcTemplate; //jdbcTemplate的set方法 供依赖注入 public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; /** * 添加 */ public void save(Account account) &#123; jdbcTemplate.update("insert into account(name,money) values(?,?)",account.getName(),account.getMoney()); &#125; /** * 根据用户id删除用户 */ public void delete(int id) &#123; jdbcTemplate.update(" delete from account where id=? ",id); &#125; /** * 根据用户名更新money */ public void update(Account account) &#123; jdbcTemplate.update(" update account set money=? where name=? ", account.getMoney(),account.getName()); &#125; /** * 根据id查找对应用户 */ public Account findByName(String name) &#123; return jdbcTemplate.queryForObject(" select * from account where name=? ", new BeanPropertyRowMapper&lt;Account&gt;(Account.class),name); &#125;&#125; 2.spring的XML配置在pom中导入依赖点击显示或隐藏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--springioc相关--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--连接池--&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-dbutils&lt;/groupId&gt; &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--jdbctemplate--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--整合junit测试所需包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在bean.xml配置文件中导入约束点击显示或隐藏 1234567&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; 导入对应的对象和注入依赖关系点击显示或隐藏 1234567891011121314151617181920212223242526272829&lt;!--需要导入约束并声明文件位置--&gt;&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;&lt;!--创建service实现类交给spring容器--&gt;&lt;bean id="accountSrevice" class="cn.itcast.service.impl.AccountServiceImpl"&gt; &lt;!--导入对应依赖--&gt; &lt;property name="accountDao" ref="accountDao"/&gt;&lt;/bean&gt;&lt;!--创建dao实现类交给spring容器--&gt;&lt;bean id="accountDao" class="cn.itcast.dao.impl.AccountDaoImpl"&gt; &lt;!--导入对应依赖--&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt;&lt;/bean&gt;&lt;!--创建jdbctemplate交给spring容器--&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;!--导入对应依赖--&gt; &lt;constructor-arg name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!--创建数据源交给spring容器--&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--导入对应依赖--&gt; &lt;property name="user" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="driverClass" value="$&#123;jdbc.driver&#125;"/&gt;&lt;/bean&gt; 3.测试测试代码(参考spring基于注解的IOC配置中三.5:spring整合Junit测试)点击显示或隐藏 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:bean.xml")public class AccountServiceTest &#123; @Autowired private AccountService accountService; /** * 添加 */ @Test public void saveTest()&#123; Account account = new Account(); account.setName("白小白"); account.setMoney(110); accountService.save(account); &#125; /** * 根据用户id删除用户 */ @Test public void deleteTest()&#123; accountService.delete(5); &#125; /** * 根据用户名更新money */ @Test public void updateTest()&#123; Account account = new Account(); account.setName("aaa"); account.setMoney(666666); accountService.update(account); &#125; /** * 根据id查找对应用户 */ @Test public void findByNameTest()&#123; Account aaa = accountService.findByName("aaa"); System.out.println(aaa); &#125;&#125; 五.请自行测试结果,结束]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>IOC,概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis入门]]></title>
    <url>%2F2016%2F11%2F21%2Fmybatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一.mybatis介绍mybatis是一个优秀的基于java的持久层框架，它内部封装了 jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 二.mybatis快速入门(简单案例)1. 环境搭建1.1 创建测试项目,普通java项目或者javaweb项目均可本文以通过maven创建的普通java项目为例,如下图: 1.2 导入需要的依赖(如下图)复制到pom中 点击显示或隐藏 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.3 准备数据库(本文使用mysql)sql脚本如下 点击显示或隐藏 12345678910111213CREATE DATABASE IF NOT EXISTS `mybatisdb`;USE `mybatisdb`;CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL COMMENT '用户名称', `birthday` DATETIME DEFAULT NULL COMMENT '生日', `sex` CHAR(1) DEFAULT NULL COMMENT '性别', `address` VARCHAR(256) DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'),(42,'小二王','2018-03-02 15:09:37','女','北京金燕龙'),(43,'小二王','2018-03-04 11:34:34','女','北京金燕龙'),(45,'传智播客','2018-03-04 12:04:06','男','北京金燕龙'),(46,'老王','2018-03-07 17:37:26','男','北京'),(48,'小马宝莉','2018-03-08 11:44:00','女','北京修正'); 2. 使用mybatis查询表中数据2.1 创建SqlMapConfig.xml核心配置(如下图) 核心配置代码如下: 点击显示或隐藏 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 2.2 定义表对应的实体类(如下图) User代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.domain;import java.util.Date;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2.3 定义操作表的sql映射文件UserMapper.xml(如下图) sql映射文件代码如下: 点击显示或隐藏 12345678910 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="cn.itcast.dao.UserDao"&gt; &lt;!-- select 查询 --&gt; &lt;select id="getUser" resultType="cn.itcast.domain.User"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 2.4 在核心配置中注册sql映射文件代码代码如下: 点击显示或隐藏 123456789101112131415161718192021 &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 注册Sql映射文件 --&gt; &lt;mappers&gt;&lt;mapper resource="UserMapper.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.5 两种使用方法2.5.1 使用代理的方法查询2.5.1.1 创建UserDao接口并定义方法(此处为查)接口代码如下: 点击显示或隐藏 12345678910111213package cn.itcast.dao;import cn.itcast.domain.User;import java.util.List;public interface UserDao &#123;/** * 查询所有user的方法 * @return */List&lt;User&gt; getUser();&#125; 2.5.1.2 创建Test测试类测试测试代码如下: 点击显示或隐藏 123456789101112131415161718192021222324252627282930313233package cn.itcast;import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.InputStream;import java.util.List;public class UserDaoTest &#123; @Test public void getUserTest()&#123; //加载文件 InputStream is = UserDaoTest.class.getClassLoader().getResourceAsStream("SqlMapConfig.xml"); //解析xml SqlSessionFactoryBuilder sfb = new SqlSessionFactoryBuilder(); //解析xml,创建Factory SqlSessionFactory build = sfb.build(is); //创建session对象 SqlSession session = build.openSession(); //通过动态代理反射获取对应接口实现类 UserDao userDao = session.getMapper(UserDao.class); //调用方法 List&lt;User&gt; user = userDao.getUser(); for (User user1 : user) &#123; System.out.println(user1); &#125; &#125;&#125; 2.5.1.3 查询结果: 2.5.2 使用传统方法查询2.5.2.1 在代理的基础上扩展增加创建UserDao的实现类UserDaoImplUserDaoImpl代码如下:12345678910111213141516171819202122package cn.itcast.dao.impl;import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory ; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; getUser() &#123; SqlSession session = factory.openSession(); //使用的是mybatis提供的方法 return session.selectList("us.findAll"); &#125;&#125; 2.5.2.2 创建Test测试类测试代码如下: 点击显示或隐藏 12345678910111213141516171819202122232425262728293031package cn.itcast;import cn.itcast.dao.UserDao;import cn.itcast.dao.impl.UserDaoImpl;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;public class UserTest &#123; private SqlSessionFactory build; @Before public void init()&#123; InputStream is = UserTest.class.getClassLoader().getResourceAsStream("SqlMapConfig.xml"); build = new SqlSessionFactoryBuilder().build(is); &#125; @Test public void getUserTest()&#123; UserDao dao = new UserDaoImpl(build); List&lt;User&gt; list = dao.findAll(); System.out.println(list); &#125;&#125; 2.5.2.3 查询结果: 三.大致就是这样了,结束]]></content>
      <categories>
        <category>mybatis框架</category>
      </categories>
      <tags>
        <tag>持久层框架,简单</tag>
      </tags>
  </entry>
</search>
