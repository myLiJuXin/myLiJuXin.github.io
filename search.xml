<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于数据库redis与Mysql的区别以及在web开发中的配合使用]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93redis%E4%B8%8EMysql%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%9C%A8web%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E9%85%8D%E5%90%88%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[传统型关系数据库Mysql的瓶颈在互联网领域，MySQL作为一款关系型数据库为互联网的发展做出了卓越的贡献。然而随着互联网的发展，在大数据量高并发的环境下，应用开发也越来越复杂，具有很强的技术挑战性。分表分库子库等无不在增加数据库结构的复杂程度。MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差，大数据下IO压力大，表结构更改困难。 Nosql与redisNoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受，指的是非关系型的数据库。 Nosql的优势易扩展：NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。大数据量，高性能：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦高可用：NoSQL在不太影响性能的情况，就可以方便的实现高可用的架构。 redisRedis是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。redis是一个高性能的key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sortedset–有序集合)和hash（哈希类型）。redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部分场合可以对关系数据库起到很好的补充作用。它提供了Python，Ruby，Erlang，PHP客户端，使用很方便Redis支持主从同步。数据可以从主服务器向任意数量的从服务器上同步，从服务器可以是关联其他从服务器的主服务器。这使得Redis可执行单层树复制。从盘可以有意无意的对数据进行写操作。由于完全实现了发布/订阅机制，使得从数据库在任何地方同步树时，可订阅一个频道并接收主服务器完整的消息发布记录。同步对读取操作的可扩展性和数据冗余很有帮助。 结论NoSQL数据库的出现，弥补了关系数据（比如MySQL）在某些方面的不足，在某些方面能极大的节省开发成本和维护成本MySQL和NoSQL都有各自的特点和使用的应用场景，两者的紧密结合将会给数据库发展带来新的思路。让关系数据库关注在关系上，NoSQL关注在存储上。 利用redis做mysql的缓存前面部分已经介绍mysql的瓶颈，当网站的处理和访问量非常大的时候，我们的数据库的压力就变大了，数据库的连接池，数据库同时处理数据的能力就会受到很大的挑战，一旦数据库承受了其最大承受能力，网站的数据处理效率就会大打折扣。此时就要使用高并发处理、负载均衡和分布式数据库，而这些技术既花费人力，又花费资金。 缓存 页面缓存经常用在CMS(content manage system)内存管理系统里面。数据缓存经常会用在页面的具体数据里面。 Redis缓存原理采用redis nosql数据库作为Mysql数据库的缓存，在查找的时候，首先查找redis缓存，如果找到则返回结果；如果在redis中没有找到，那么查找Mysql数据库，找到的花则返回结果并且更新redis；如果没有找到则返回空。 对于写入：用户增删改数据库，先访问mysql，mysql再把数据更新到redis。 Mysql中的数据都是按表存储的；更微观地看，这些表都是按行存储的。每执行一次select查询，Mysql都会返回一个结果集，这个结果集由若干行组成。所以，一个自然而然的想法就是在Redis中找到一种对应于Mysql行的数据结构。Redis中提供了五种基本数据结构，即字符串（string）、列表（list）、哈希（hash）、集合（set）和有序集合（sorted set）。经过调研，发现适合存储行的数据结构有两种，即string和hash。 用户的缓存数据在返回时一般都是JSON的字典格式，对应的存到redis里就是hash格式，这个与python的字典是相对应的。 redis中的hash python中的字典 key 对象 field key value value 即hash会根据要缓存的数据生成唯一标识UUID，UUID作为键，用户的字典数据中的键值对作为UUID键的值，存储到redis中。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库,redis,mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux终端的常用命令（一）]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux由Unix发展而来，于1991年林纳斯（linus）发布，分为内核与发行版，内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，主要做一些基本的，也是重要的操作。比如进程管理、内存管理、磁盘管理、驱动管理、电源管理、安全管理等。Linux 内核版本又分为 稳定版 和 开发版，两种版本是相互关联，相互循环。稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序开发版：由于要试验各种解决方案，所以变化很快内核源码网址：点这里&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux发行版通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。主要有：ubantu，centos，redhat, debian等，这里主要是ubantu的基本常用命令。### Linux终端命令基本使用———-终端命令格式：Command 【-options（选项，可以配合使用）】【parameter（对象）】 1. 查看文件信息（在当前路径下输入即可查看当前路径文件）123ls -l # 查看详情ls -a # 查看所有文件ls -h # 配合-l显示文件大小 2. 通配符，可以代替字符12* # 代表0个或多个任意字符？ # 代表任意一个字符 3. 清屏12clear按键：ctrl +L 4. 切换路径（分为相对路径和绝对路径，相对路径从当前目录开始；绝对路径从根目录（/）开始）12cd ./Desktop # .代表当前路径cd ../ # ..代表上一级路径 5. 显示当前绝对路径1pwd 6. 创建目录12mkdir 目录名mkdir a/b/c -p # 创建级联目录 7. 创建文件（文件名指定后缀名）12touch 文件名touch 文件1 文件2 文件3 # 创建多个文件 8. 删除文件，目录123rm -i # 删除文件给予交互提示rm -f # 强制删除rm -r # 递归删除，删除目录 9. 拷贝文件，目录12345cp 【源文件名】【目标目录路径】# 拷贝文件不能在本目录下，不能重名例： cp 1.txt ./a 将1.txt复制到当前目录的a目录下cp 【源文件名】【目标文件名】# 拷贝并重命名例： cp a.txt b.txt 复制a并命名为b选项： -r 拷贝文件夹 -f 强制拷贝 -i交互提示 10. 移动文件，文件夹12mv 【源文件名】【移动目标路径】# 移动目录不用-r 例：mv 1.txt ./a 将1文件移动到当前目录的a目录下mv 【源文件名】【移动后文件名】# 重命名，不能重名 例： mv a.py b.py 11. 树状显示目录1tree 12. 查看历史命令12history # 显示历史命令！数字 # 引用某一行命令 例：！20，引用20行命令 13. 查看，写入文件内容12cat 【文件名】 # 查看 例：cat 1.txtgedit 【文件名】# 写入 例 ： gedit 1.txt 14. 重定向（将命令执行结果保存到另一个文件中）123&gt; # 覆盖&gt;&gt; # 追加 例： cat 1.txt 2.txt &gt; 3,txt 将1,2两个文件的内容重定向到3里，3.txt不存在则创建 15. 分屏显示内容1more # 分屏显示文件内容，一般接到其他命令后，空格切换屏幕]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Linux的常用基本命令（二）]]></title>
    <url>%2F2018%2F08%2F21%2F%E5%85%B3%E4%BA%8ELinux%E7%9A%84%E7%BB%88%E7%AB%AF%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接上面《关于Linux的常用基本命令（一）》点这里#### 管道命令1【命令1】 | 【命令2】 # 命令1的输出结果作为命令2的输入#### 查找某个文件的文本1234grep 【选项】 “字符串” 【文件】选项：-i 忽略大小写 -n 显示匹配行及行号 -v 取反（显示余下的信息）例： ps -aux | grep ’mysql‘ 查看运行中的进程，带有mysql的进程 查找文件1234find 【路径】 【选项】选项：-name ’字符串‘ # 查找该文件名的文件 -size +（-）’大小‘ # 查找文件大于（小于）多少的文件 -permission 权限 # 查找拥有该权限的文件 tar打包压缩文件与解压缩12345678tar 【选项】【打包后的文件名】【 要打包的文件名】选项： -c 生成打包文件 -v 显示进度 -f 指定打包文件名称，所以f选项要放最后 -x 拆包解包 -z gzip格式压缩解压 -j bzip2格式压缩解压 c 指定目录 gzip格式压缩解压12gizp 【文件名】 # 压缩文件gzip -d 【文件名】 # 解压缩文件 查看命令位置1which 查看当前用户登录1who # tty 本地登录 pts 远程登录 授权当前用户执行命令1sudo # 管理员权限 退出终端，回到上一用户，退出远程1exit 软件卸载与安装123sudo apt-get install “安装包” # 安装sudo apt-get remove “安装包” # 删除sudo apt-get update “安装包” # 更新 关机重启12shutdown -h now （或加时间） # 立即关机，或者多少时间后关机 -r # 重启]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis学习笔记(第一天)]]></title>
    <url>%2F2018%2F08%2F21%2Fmybatis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[一.mybatis介绍&amp;nbsp &amp;nbsp mybatis是一个优秀的基于java的持久层框架，它内部封装了 jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。&amp;nbsp &amp;nbsp mybatis通过xml或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。&amp;nbsp &amp;nbsp 采用ORM思想解决了实体和数据库映射的问题，对jdbc进行了封装，屏蔽了jdbc api底层访问细节，使我们不用与 jdbc api 打交道，就可以完成对数据库的持久化操作。 二.mybatis快速入门(简单案例)1. 环境搭建1.1 创建测试项目,普通java项目或者javaweb项目均可本文以通过maven创建的普通java项目为例,如下图: 1.2 导入需要的依赖(如下图)复制到pom中 点击显示或隐藏 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;dom4j&lt;/groupId&gt; &lt;artifactId&gt;dom4j&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jaxen&lt;/groupId&gt; &lt;artifactId&gt;jaxen&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.3 准备数据库(本文使用mysql)sql脚本如下 点击显示或隐藏 12345678910111213CREATE DATABASE IF NOT EXISTS `mybatisdb`;USE `mybatisdb`;CREATE TABLE `user` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `username` VARCHAR(32) NOT NULL COMMENT '用户名称', `birthday` DATETIME DEFAULT NULL COMMENT '生日', `sex` CHAR(1) DEFAULT NULL COMMENT '性别', `address` VARCHAR(256) DEFAULT NULL COMMENT '地址', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; insert into `user`(`id`,`username`,`birthday`,`sex`,`address`) values (41,'老王','2018-02-27 17:47:08','男','北京'),(42,'小二王','2018-03-02 15:09:37','女','北京金燕龙'),(43,'小二王','2018-03-04 11:34:34','女','北京金燕龙'),(45,'传智播客','2018-03-04 12:04:06','男','北京金燕龙'),(46,'老王','2018-03-07 17:37:26','男','北京'),(48,'小马宝莉','2018-03-08 11:44:00','女','北京修正'); 2. 使用mybatis查询表中数据2.1 创建SqlMapConfig.xml核心配置(如下图) 核心配置代码如下: 点击显示或隐藏 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 2.2 定义表对应的实体类(如下图) User代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package cn.itcast.domain;import java.util.Date;public class User &#123; private Integer id; private String username; private Date birthday; private String sex; private String address; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public Date getBirthday() &#123; return birthday; &#125; public void setBirthday(Date birthday) &#123; this.birthday = birthday; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 2.3 定义操作表的sql映射文件UserMapper.xml(如下图) sql映射文件代码如下: 点击显示或隐藏 12345678910 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt; &lt;mapper namespace="cn.itcast.dao.UserDao"&gt; &lt;!-- select 查询 --&gt; &lt;select id="getUser" resultType="cn.itcast.domain.User"&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; 2.4 在核心配置中注册sql映射文件代码代码如下: 点击显示或隐藏 123456789101112131415161718192021 &lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC" /&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver" &gt;&lt;/property&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/mybatisdb?characterEncoding=utf8" &gt;&lt;/property&gt; &lt;property name="username" value="root"&gt;&lt;/property&gt; &lt;property name="password" value="root"&gt;&lt;/property&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;!-- 注册Sql映射文件 --&gt; &lt;mappers&gt;&lt;mapper resource="UserMapper.xml"&gt;&lt;/mapper&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.5 两种使用方法2.5.1 使用代理的方法查询2.5.1.1 创建UserDao接口并定义方法(此处为查)接口代码如下: 点击显示或隐藏 12345678910111213package cn.itcast.dao;import cn.itcast.domain.User;import java.util.List;public interface UserDao &#123;/** * 查询所有user的方法 * @return */List&lt;User&gt; getUser();&#125; 2.5.1.2 创建Test测试类测试测试代码如下: 点击显示或隐藏 123456789101112131415161718192021222324252627282930313233package cn.itcast;import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.InputStream;import java.util.List;public class UserDaoTest &#123; @Test public void getUserTest()&#123; //加载文件 InputStream is = UserDaoTest.class.getClassLoader().getResourceAsStream("SqlMapConfig.xml"); //解析xml SqlSessionFactoryBuilder sfb = new SqlSessionFactoryBuilder(); //解析xml,创建Factory SqlSessionFactory build = sfb.build(is); //创建session对象 SqlSession session = build.openSession(); //通过动态代理反射获取对应接口实现类 UserDao userDao = session.getMapper(UserDao.class); //调用方法 List&lt;User&gt; user = userDao.getUser(); for (User user1 : user) &#123; System.out.println(user1); &#125; &#125;&#125; 2.5.1.3 查询结果: 2.5.2 使用传统方法查询2.5.2.1 在代理的基础上扩展增加创建UserDao的实现类UserDaoImplUserDaoImpl代码如下:12345678910111213141516171819202122package cn.itcast.dao.impl;import cn.itcast.dao.UserDao;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import java.util.List;public class UserDaoImpl implements UserDao &#123; private SqlSessionFactory factory ; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; public List&lt;User&gt; getUser() &#123; SqlSession session = factory.openSession(); //使用的是mybatis提供的方法 return session.selectList("us.findAll"); &#125;&#125; 2.5.2.2 创建Test测试类测试代码如下: 点击显示或隐藏 12345678910111213141516171819202122232425262728293031package cn.itcast;import cn.itcast.dao.UserDao;import cn.itcast.dao.impl.UserDaoImpl;import cn.itcast.domain.User;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Before;import org.junit.Test;import java.io.InputStream;import java.util.Date;import java.util.List;public class UserTest &#123; private SqlSessionFactory build; @Before public void init()&#123; InputStream is = UserTest.class.getClassLoader().getResourceAsStream("SqlMapConfig.xml"); build = new SqlSessionFactoryBuilder().build(is); &#125; @Test public void getUserTest()&#123; UserDao dao = new UserDaoImpl(build); List&lt;User&gt; list = dao.findAll(); System.out.println(list); &#125;&#125; 2.5.2.3 查询结果: 三.大致就是这样了,结束]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>持久层框架,简单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[亲爱的,七夕快乐]]></title>
    <url>%2F2018%2F08%2F17%2Ffilename%2F</url>
    <content type="text"><![CDATA[第一篇博客1831天,有你陪伴,我的幸运,七夕快乐,你期待的我一定会将它实现,余生请多指教]]></content>
      <categories>
        <category>情感</category>
      </categories>
      <tags>
        <tag>第一篇</tag>
      </tags>
  </entry>
</search>
